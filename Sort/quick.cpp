/*************************************************************************
	> File Name: quick.cpp
	> Author: jiexue
	> Mail: jiexuelc@163.com
	> Created Time: Tue 05 Jun 2018 08:02:20 PM CST
	> Description: 时间复杂度Ｏ(NlogN)快速排序
 ************************************************************************/

#include<algorithm>
using std::swap;

//void quick_sort(int* a,int n)
void sort(int* a,int n)
{
	if(n <= 1) return;//如果分组成员不大于１个，不用排序
	
	/*如果成员刚好为两个，直接比较将其位置交换*/
	if(n == 2) {
		if(a[1] < a[0])
			swap(a[1],a[0]);
	}
	swap(a[n/2],a[0]);//选择组中间的值作为分界值
	int jie = a[0];
	int* L = a+1;//左指针指向组开始
	int* R = a+n-1;//右指针指向组最后
	
	/*左右指针分别向中间寻找，左指针找到比分界值大的值和右指针找到比分界值小的值互相交换*/
	while(L < R){
		
		//左指针从左向右寻找,遇到不小于分界值的位置停下来；倘若右边所有值都小于分界值，那么L指针停在最后一个位置
		while(L < R && *L < jie) ++L;//遇到相等的值也停下来
		
		//右指针从右向左寻找，遇到小于分界值的位置停下来；如果左边的值都不小于分界值，那么将停在组的开始位置
		while(a < R && !(*R < jie)) --R;//遇到相等的值不必停下来，因为右边与分界值相等的不用移动
		if(L < R) swap(*L,*R);//判断如果左右指针不相交说明没有查找完成，需要交换
	}
	if(*R < jie) //右指针停下来指向的值一定是小于分界值的，这一句可以去掉
		swap(*R,a[0]);//左右指针相交，将分界值与右指针找到的比分界值小的值与分界值位置进行交换
	sort(a,R-a);//将分界值左边的组进行分组排序
	sort(R+1,n-1-(R-a));//将分界值右边的组进行分组排序
}